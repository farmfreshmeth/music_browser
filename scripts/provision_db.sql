/*
  provision_db.sql
    Bootstraps a music_browser postgres database from bare install

  Before you can run this, do this by hand
    $ psql postgres
    postgres=# CREATE ROLE farmfreshmeth WITH LOGIN CREATEDB;
    CREATE ROLE
    postgres=# CREATE DATABASE music_browser WITH OWNER farmfreshmeth;
    CREATE DATABASE
    postgres=# CREATE DATABASE music_browser_test WITH OWNER farmfreshmeth;
    CREATE DATABASE
    postgres=# quit

  Usage:
    $ psql -U farmfreshmeth -d music_browser -f scripts/provision_db.sql
    $ psql -U farmfreshmeth -d music_browser_test -f scripts/provision_db.sql
    $ heroku pg:psql postgresql-shaped-78815 --app music-browser -f scripts/provision_db.sql
*/

---- Initial schema ----
DROP TABLE IF EXISTS
  folders, fields, items, lyrics, log, wants,
  notes, session, users CASCADE;

CREATE TABLE folders (
  key         integer PRIMARY KEY,
  value       jsonb
);
CREATE UNIQUE INDEX folders_pk ON folders (key);

CREATE TABLE fields (
  key         integer PRIMARY KEY,
  value       jsonb
);
CREATE UNIQUE INDEX fields_pk ON fields (key);

CREATE TABLE items (
  key         integer PRIMARY KEY,
  value       jsonb
);
CREATE UNIQUE INDEX items_pk ON items (key);

---- Migration 20240402 ----
CREATE INDEX idx_items ON items USING GIN (value);
CREATE INDEX idx_artists_sort ON items USING GIN ((value -> 'artists_sort'));
CREATE INDEX idx_release_title ON items USING GIN ((value -> 'title'));
CREATE INDEX idx_release_artists ON items USING GIN ((value -> 'artists'));

---- Migration 20240406 ----
CREATE TABLE lyrics (
  item_key        integer,
  artist          varchar(100),
  track_title     varchar(255),
  track_position  varchar(20),
  lyrics          text,
  PRIMARY KEY (item_key, track_position)
);
CREATE INDEX fk_item_key ON lyrics (item_key);
CREATE INDEX idx_track_position ON lyrics (track_position);
CREATE INDEX idx_track_title ON lyrics (track_title);

CREATE TABLE state (
  key           integer PRIMARY KEY,
  value         jsonb
);
CREATE UNIQUE INDEX state_pk ON state (key);

CREATE TABLE log (
  ts            timestamp with time zone NOT NULL DEFAULT NOW(),
  env           varchar(40),
  job           varchar(40),
  level         varchar(20),
  message       text
);
CREATE INDEX idx_ts ON log (ts);

---- Migration 20240416 ----
CREATE TABLE wants (
  key           integer PRIMARY KEY,
  value         jsonb
);
CREATE UNIQUE INDEX wants_pk ON wants (key);

---- Migration 20240417 ----
DELETE FROM items WHERE value IS NULL;
ALTER TABLE items ALTER COLUMN value SET NOT NULL;

---- Migration 20240418 ----
CREATE TABLE "session" (
  "sid" varchar NOT NULL COLLATE "default",
  "sess" json NOT NULL,
  "expire" timestamp(6) NOT NULL
)
WITH (OIDS=FALSE);
ALTER TABLE "session" ADD CONSTRAINT "session_pkey" PRIMARY KEY ("sid") NOT DEFERRABLE INITIALLY IMMEDIATE;
CREATE INDEX "IDX_session_expire" ON "session" ("expire");

CREATE TABLE users (
  id                integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  email             varchar(255),
  first_name        varchar(50),
  last_name         varchar(50),
  password          varchar(64),
  privileges        jsonb,
  CONSTRAINT unique_email UNIQUE(email)
);
CREATE UNIQUE INDEX idx_user_email ON users (email);

---- Migration 20240425-01 ----
DROP TABLE state;

---- Migration 20240425-02 ----
CREATE TABLE notes (
  id                serial PRIMARY KEY,
  resource_id       varchar(64) NOT NULL,
  resource_type     varchar(64) NOT NULL,
  note              text,
  created_at        timestamp NOT NULL DEFAULT NOW(),
  updated_at        timestamp DEFAULT NOW(),
  created_by        integer,
  search            tsvector GENERATED ALWAYS AS (to_tsvector('english', note)) STORED
);
CREATE INDEX notes_vector ON notes USING gin(search);
CREATE INDEX idx_resource ON notes (resource_id, resource_type);
